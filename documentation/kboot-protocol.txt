KBoot Boot Protocol
===================

License
-------

Copyright &copy; 2012 Alex Smith

This document is distributed under the terms of the [Creative Commons
Attribution-ShareAlike 3.0 Unported](http://creativecommons.org/licenses/
by-sa/3.0/) license.

Introduction
------------

The purpose of this document is to specify the KBoot Boot Protocol, a method
for loading an operating system kernel and providing information to it.

The following sections describe the format of the information provided to the
boot loader in the kernel image, the format of the information that the boot
loader provides to the kernel, and the machine state upon entering the kernel.

Basic Definitions
-----------------

This specification uses C syntax to define the KBoot structures. Structures are
assumed to be implicitly padded to achieve natural alignment for each field.
Only the standard C fixed-width integer types are used, to ensure that it is
clear what size each field should be. The following additional type aliases are
defined:

    typedef uint64_t kboot_paddr_t;
    typedef uint64_t kboot_vaddr_t;

These types are used to store physical and virtual addresses, respectively.
They are fixed to 64 bits in order to keep the format of all structures the
same across architectures.

Kernel Image
------------

A KBoot kernel is an ELF32 or ELF64 image annotated with ELF note sections to
specify to the boot loader how it wishes to be loaded, options that can be
edited by the user to control kernel behaviour, among other things. These
sections are referred to as "image tags". All integer values contained within
the image tags are stored in the byte order specified by the ELF header.

ELF notes have the following format:

 * _Name Size_: 32-bit integer. Size of the Name field, in bytes.
 * _Desc Size_: 32-bit integer. Size of the Desc field, in bytes.
 * _Type_: 32-bit integer. Type of the note.
 * _Name_: String identifying the vendor who defined the format of the note.
   Padded to a 4 or 8 byte boundary.
 * _Desc_: Data contained in the note. Padded to a 4 or 8 byte boundary.

The padding of the Name and Desc fields is 4 bytes for 32-bit ELF files, and 8
bytes for 64-bit.

For a KBoot image tag, the Name field is set to `"KBoot\0"`, the Type field is
set to the identifier of the image tag type, and the Desc field contains the
tag data.

The KBoot header file included with the KBoot boot loader defines macros for
creating all image tag types that expand to an inline ASM code chunk that
correctly defines the note section.

The following image tag types are defined (given as "Name (type ID)"):

### `KBOOT_ITAG_IMAGE` (`0`)

This image tag is the only tag that is required to be present in a kernel image.
All other tags are optional. It is used to identify the image as a KBoot kernel.

    typedef struct kboot_itag_image {
    	uint32_t version;
    	uint32_t flags;
    } kboot_itag_image_t;

Fields:

 * `version`: Number defining the KBoot protocol version that the kernel is
   using. The version number can be used by a boot loader to determine whether
   additions in later versions of this specification are present. The current
   version number is 1.
 * `flags`: Flags controlling whether certain optional features should be
   enabled. The following flags are currently defined:
    - `KBOOT_IMAGE_SECTIONS` (bit 0): Load additional ELF sections and pass
      section header table to the kernel (see `KBOOT_TAG_SECTIONS`).
    - `KBOOT_IMAGE_LOG` (bit 1): Enable the kernel log facility (see
      `KBOOT_TAG_LOG`).

### `KBOOT_ITAG_LOAD` (`1`)

This tag can be used for more control over the physical and virtual memory
layout set up by the boot loader.

    typedef struct kboot_itag_load {
    	uint32_t      flags;
    	kboot_paddr_t alignment;
    	kboot_paddr_t min_alignment;
    	kboot_paddr_t phys_address;
    	kboot_vaddr_t virt_map_base;
    	kboot_vaddr_t virt_map_size;
    } kboot_itag_load_t;

Fields:

 * `flags`: Flags controlling load behaviour. The following flags are currently
   defined:
    - `KBOOT_LOAD_FIXED` (bit 0): Load at a fixed physical address, given by the
      `phys_address` field. The `alignment` and `min_alignment` fields will be
      ignored.
 * `alignment`: Requested alignment of the kernel image in physical memory. If
   this is set to 0, the alignment will be chosen automatically by the boot
   loader. Otherwise, it must be a power of 2 greater than the machine's page
   size.
 * `min_alignment`: Minimum physical alignment. If non-zero and less than the
   `alignment` value, if the loader is unable to allocate at `alignment` it
   will repeatedly try to allocate at decreasing powers of 2 down to this value
   until it is able to make an allocation. If 0, `alignment` will also be the
   minimum alignment.
 * `phys_address`: If `KBOOT_LOAD_FIXED` set, load at this exact physical
   address.
 * `virt_map_base`/`virt_map_size`: The boot loader allocates regions of the
   virtual address space to map certain things into, such as the tag list for
   the kernel and the video framebuffer. These fields specify the region of
   virtual address space that these mappings should be made in. If both 0, the
   boot loader may place its mappings at any location in the virtual address
   space.

If this tag is not present in the kernel image, all fields will default to 0.

### `KBOOT_ITAG_OPTION` (`2`)

Multiple option tags can be included in a kernel image. Each describes an
option for the kernel that can be configured by the user via the boot loader.
The boot loader can use the information given by these tags, for example, to
display a configuration menu.

    typedef struct kboot_itag_option {
    	uint8_t  type;
    	uint32_t name_len;
    	uint32_t desc_len;
    	uint32_t default_len;
    } kboot_itag_option_t;

This structure is followed by 3 variable length fields: `name`, `desc` and
`default`.

Fields:

 * `type`: Type of the option. What is in the `default` field depends on the
   option type. The following option types are defined:
   - `KBOOT_OPTION_BOOLEAN` (0): Boolean, 1 byte, 0 or 1.
   - `KBOOT_OPTION_STRING` (1): String, variable length, null-terminated string
     (length includes null terminator).
   - `KBOOT_OPTION_INTEGER` (2): Integer, 8 bytes, 64-bit integer.
 * `name_len`: Length of the `name` field, including null terminator.
 * `desc_len`: Length of the `desc` field, including null terminator.
 * `default_len`: Length of the `default` field. Dependent on `type`, see above.
 * `name`: String name of the option. Must not contain spaces, or any of the
   following characters: `" '`. Names of the format `option_name` are
   recommended.
 * `desc`: Human readable description for the option, for use in configuration
   menus in the boot loader.
 * `default`: Default value of the option. Dependent on `type`, see above.

### `KBOOT_ITAG_MAPPING` (`3`)

This tag specifies a range of physical memory to map in to the kernel virtual
address space.

    typedef struct kboot_itag_mapping {
    	kboot_vaddr_t virt;
    	kboot_paddr_t phys;
    	kboot_vaddr_t size;
    } kboot_itag_mapping_t;

Fields:

 * `virt`: The virtual address to map at. If this is set to the special value
   `0xFFFFFFFFFFFFFFFF`, then the boot loader will allocate an address to map
   at. The allocated address can be found in the kernel by iterating over the
   provided virtual address space map to find an entry with matching physical
   address and size. Otherwise, the exact address specified (must be aligned to
   the page size) is used.
 * `phys`: The physical address to map to (must be aligned to the page size).
 * `size`: The size of the range to map (must be a multiple of the page size).

For more information on the procedure used to build the virtual address space
for the kernel, see the _Kernel Environment_ section.

### `KBOOT_ITAG_VIDEO` (`4`)

This tag is used to specify to the boot loader what video types are supported
and what display mode it should attempt to set.

    typedef struct kboot_itag_video {
    	uint32_t types;
    	uint32_t width;
    	uint32_t height;
    	uint8_t  bpp;
    } kboot_itag_video_t;

Fields:

 * `types`: Bitfield of supported video types. The following video types are
   currently defined:
    - `KBOOT_VIDEO_VGA` (bit 0): VGA text mode.
    - `KBOOT_VIDEO_LFB` (bit 1): Linear framebuffer.
 * `width`/`height`/`bpp`: Preferred mode for `KBOOT_VIDEO_LFB`. If this mode
   is available it will be set, otherwise one as close as possible will be set.
   If all fields are 0, a mode will be chosen automatically.

What types are supported, the default video setup if this tag is not present,
and the precedence of types all depend on the platform. Furthermore, some
platforms may not support video mode setting at all. On such platforms the
kernel should use other means of output, such as a UART. See the _Platform
Specifics_ section for details of the video support on each platform.

Kernel Environment
------------------

The kernel entry point takes 2 arguments:

    void kmain(uint32_t magic, kboot_tag_t *tags);

The first argument is the magic value, `0xB007CAFE`, which can be used by the
kernel to ensure that it has been loaded by a KBoot boot loader. The second
argument is a pointer to the first tag in the information tag list, described
in the _Kernel Information_ section.

The kernel is entered with the MMU enabled. A virtual address space is set up
by the boot loader which maps the kernel and certain other things, as well as
an architecture-dependent method to be able to manipulate the virtual address
space (see below). The following procedure is used to build the address space:

 * Map the kernel image.
 * Map ranges specified by `KBOOT_ITAG_MAPPING` tags.
 * Allocate space for other mappings (e.g. tag list, framebuffer, log buffer)
   within the address range specified by the `KBOOT_ITAG_LOAD` tag.
 * Allocate space for the stack.

A map of the virtual address space is provided in the tag list, see
`KBOOT_TAG_VMEM`. Note that the address space set up by the boot loader is
intended to only be temporary. The kernel should build its own address space
using the information provided by KBoot as soon as possible.

On all architectures, the kernel will be entered with a valid stack set up,
mapped in the virtual address space. Details of the stack mapping are contained
in the `KBOOT_TAG_CORE` information tag. The physical memory used by the stack
is marked in the memory map as allocated; if the kernel switches away from this
stack as part of its initialization it should be sure to free the physical
memory used by it.

The following sections describe the environment upon entering the kernel for
each supported architecture.

### x86

The arguments to the kernel entry point are passed on the stack. The machine
state upon entry to the kernel is as follows:

 * In 32-bit protected mode, paging enabled. A20 line is enabled.
 * CS is set to a flat 32-bit read/execute code segment. The exact value is
   undefined.
 * DS/ES/FS/GS/SS are set to a flat 32-bit read/write data segment. The exact
   values are undefined.
 * All bits in EFLAGS are clear except for bit 1, which must always be 1.
 * EBP is 0.
 * ESP points to a valid stack mapped in the virtual address space set up by
   the boot loader.
    - KBoot magic value at offset 4.
    - Tag list pointer at offset 8.

Other machine state is not defined. In particular, the state of GDTR and IDTR
may not be valid, the kernel should set up its own GDT and IDT.

To allow the kernel to manipulate the virtual address space, the page directory
is recursively mapped. A 4MB region of address space is allocated, and the page
directory entry for that range is set to point to itself. The format of the
`KBOOT_TAG_PAGETABLES` tag for x86 is as follows:

    typedef struct kboot_tag_pagetables {
    	kboot_tag_t header;
    
    	kboot_paddr_t page_dir;
    	kboot_vaddr_t mapping;
    } kboot_tag_pagetables_t;

Fields:

 * `page_dir`: Physical address of the page directory.
 * `mapping`: Virtual address of the recursive page directory mapping.

### x86_64

The arguments to the kernel entry point are passed as per the AMD64 ABI. The
machine state upon entry to the kernel is as follows:

 * RDI contains the KBoot magic value.
 * RSI contains the tag list pointer.
 * In 64-bit long mode, paging enabled, A20 line is enabled.
 * CS is set to a flat 64-bit read/execute code segment. The exact value is
   undefined.
 * SS is set to a flat 32-bit read/write data segment. The exact value is
   undefined.
 * DS/ES/FS/GS are set to 0.
 * All bits in RFLAGS are clear except for bit 1, which must always be 1.
 * RBP is 0.
 * RSP points to a valid stack mapped in the virtual address space set up by
   the boot loader.

To allow the kernel to manipulate the virtual address space, the PML4 is
recursively mapped. A 512GB region of the virtual address space is allocated,
and the PML4 entry for that range is set to point to itself. Since this is such
a large region, it is _not_ allocated from the available range stated in the
`KBOOT_ITAG_LOAD` tag. Instead, the first available PML4 entry searching back
from the end of the virtual address space is chosen. The format of the
`KBOOT_TAG_PAGETABLES` tag for x86_64 is as follows:

    typedef struct kboot_tag_pagetables {
    	kboot_tag_t header;
    
    	kboot_paddr_t page_dir;
    	kboot_vaddr_t mapping;
    } kboot_tag_pagetables_t;

Fields:

 * `page_dir`: Physical address of the page directory.
 * `mapping`: Virtual address of the recursive page directory mapping.

### ARM

TODO

Kernel Information
------------------

Once the kernel has been loaded, the boot loader provides a set of information
to it describing the environment that it is running in, options that were set by
the user, modules that were loaded, etc. This information is provided as a list
of "information tags". The tag list is a contiguous list of structures, each
with an identical header identifying the type and size of that tag. The start
of the tag list is aligned to the page size, and the start of each tag is
aligned on an 8 byte boundary after the end of the previous tag. The tag list
is terminated with an `KBOOT_TAG_NONE` tag. The tag list is mapped in a virtual
memory range, and the physical memory containing it is marked as reclaimable.

The header of each tag is in the following format:

    typedef struct kboot_tag {
    	uint32_t type;
    	uint32_t size;
    } kboot_tag_t;

Fields:

 * `type`: Type ID for this tag.
 * `size`: Total size of the tag data, including the header. The location of
   the next tag is given by `ROUND_UP(current_tag + current_tag->size, 8)`.

The following sections define all of the tag types that can appear in the tag
list (given as "Name (type ID)").

### `KBOOT_TAG_NONE` (`0`)

This tag signals the end of the tag list. It contains no extra data other than
the header.

### `KBOOT_TAG_CORE` (`1`)

This tag is always present in the tag list, and it is always the first tag in
the list.

    typedef struct kboot_tag_core {
    	kboot_tag_t   header;
    
    	kboot_paddr_t tags_phys;
    	uint32_t      tags_size;
    	kboot_paddr_t kernel_phys;
    	kboot_vaddr_t stack_base;
    	uint32_t      stack_size;
    	kboot_paddr_t stack_phys;
    } kboot_tag_core_t;

Fields:

 * `tags_phys`: Physical address of the tag list.
 * `tags_size`: Total size of the tag data in bytes, rounded up to an 8 byte
   boundary.
 * `kernel_phys`: The physical load address of the kernel image.
 * `stack_base`: The virtual address of the base of the boot stack.
 * `stack_size`: The size of the boot stack in bytes.
 * `stack_phys`: The physical address of the base of the boot stack.

### `KBOOT_TAG_OPTION` (`2`)

This tag gives details of the value of a kernel option. For each option defined
by a `KBOOT_ITAG_OPTION` image tag, a `KBOOT_TAG_OPTION` will be present to
give the option value.

    typedef struct kboot_tag_option {
    	kboot_tag_t header;
    
    	uint8_t     type;
    	uint32_t    name_size;
    	uint32_t    value_size;
    } kboot_tag_option_t;

This structure is followed by 2 variable length fields, `name` and `value`.

Fields:

 * `type`: Type of the option (see `KBOOT_ITAG_OPTION`).
 * `name_size`: Length of the name string, including null terminator.
 * `value_size`: Size of the option value, in bytes.
 * `name`: Name of the option. The start of this field is the end of the tag
   structure, aligned up to an 8 byte boundary.
 * `value`: Value of the option, dependent on the type (see `KBOOT_ITAG_OPTION`).
   The start of this field is the end of the name string, aligned up to an 8
   byte boundary.

### `KBOOT_TAG_MEMORY` (`3`)

The set of `KBOOT_TAG_MEMORY` tags in the tag list describe the physical memory
available for use by the kernel. This memory map is derived from a platform-
specific memory map and also details which ranges of memory contain the kernel,
modules, KBoot data, etc. All ranges are page-aligned, and no ranges will
overlap. The minimum set of ranges possible are given, i.e. adjacent ranges of
the same type are coalesced into a single range. Note that this memory map does
_not_ describe platform-specific memory regions such as memory used for ACPI
data. It only contains information about usable RAM. Depending on the platform,
additional information may be included in the tag list about such regions. See
the _Platform Specifics_ section for more information.

    typedef struct kboot_tag_memory {
    	kboot_tag_t   header;
    
    	kboot_paddr_t start;
    	kboot_paddr_t size;
    	uint8_t       type;
    } kboot_tag_memory_t;

Fields:

 * `start`: Start address of the range. Aligned to the page size.
 * `size`: Size of the range. Multiple of the page size.
 * `type`: Type of the range. The following types are currently defined:
    - `KBOOT_MEMORY_FREE` (0): Free memory available for the kernel to use.
    - `KBOOT_MEMORY_ALLOCATED` (1): Memory allocated by the boot loader to
      contain the kernel image, stack, or other data.
    - `KBOOT_MEMORY_RECLAIMABLE` (2): Memory that currently contains KBoot
      data, but can be freed after kernel initialization is complete. The tag
      list is contained in such a range.

### `KBOOT_TAG_VMEM` (`4`)

The set of `KBOOT_TAG_VMEM` tags describe all virtual memory mappings that
exist in the kernel virtual address space.

    typedef struct kboot_tag_vmem {
    	kboot_tag_t   header;
    
    	kboot_vaddr_t start;
    	kboot_vaddr_t size;
    	kboot_paddr_t phys;
    } kboot_tag_vmem_t;

Fields:

 * `start`: Start address of the virtual memory range. Aligned to the page size.
 * `size`: Size of the virtual memory range. Multiple of the page size.
 * `phys`: Start of the physical memory range that this range maps to. If set
   to `0xFFFFFFFFFFFFFFFF`, ignore this value (virtual range is a special
   mapping, such as a recursive page directory mapping).

### `KBOOT_TAG_PAGETABLES` (`5`)

This tag contains information required to allow the kernel to manipulate virtual
address mappings. The content of this tag is architecture-specific. For more
information see the _Kernel Environment_ section.

### `KBOOT_TAG_MODULE` (`6`)

KBoot allows "modules" to be loaded and passed to the kernel. As far as KBoot
and the boot loader is aware, a module is simply a regular file that is loaded
into a memory and passed to the kernel. Interpretation of the loaded data is
up to the kernel. Possible uses are loading drivers necessary for the kernel to
be able to access the boot filesystem, or loading a file system image to run
the OS from. Each instance of this tag describes one of the modules that has
been loaded.

    typedef struct kboot_tag_module {
    	kboot_tag_t   header;
    
    	kboot_paddr_t addr;
    	uint32_t      size;
    } kboot_tag_module_t;

Fields:

 * `addr`: Physical address at which the module data is located, aligned to the
   page size. The data is not mapped into the virtual address space. Note that
   the memory containing module data is marked as reclaimable in the memory map.
   If the data is still required after kernel initialization, ensure that it is
   not freed.
 * `size`: Size of the module data, in bytes.

### `KBOOT_TAG_VIDEO` (`7`)

This tag describes the current video mode. This tag may not always be present,
whether it is is platform dependent. For more details, see `KBOOT_ITAG_VIDEO`
and the _Platform Specifics_ section.

    typedef struct kboot_colour {
    	uint8_t red;
    	uint8_t green;
    	uint8_t blue;
    } kboot_colour_t;
    
    typedef struct kboot_tag_video {
    	kboot_tag_t header;
    
    	uint8_t     type;
    
    	union {
    		struct {
    			uint8_t        cols;
    			uint8_t        lines;
    			uint8_t        x;
    			uint8_t        y;
    			kboot_paddr_t  mem_phys;
    			kboot_vaddr_t  mem_virt;
    			uint32_t       mem_size;
    		} vga;
    
    		struct {
    			uint8_t        type;
    			uint32_t       flags;
    			uint32_t       width;
    			uint32_t       height;
    			uint8_t        bpp;
    			uint32_t       pitch;
    			kboot_paddr_t  fb_phys;
    			kboot_vaddr_t  fb_virt;
    			uint32_t       fb_size;
    			uint8_t        red_size;
    			uint8_t        red_pos;
    			uint8_t        green_size;
    			uint8_t        green_pos;
    			uint8_t        blue_size;
    			uint8_t        blue_pos;
    			uint16_t       palette_size;
    			kboot_colour_t palette[0];
    		} lfb;
    	};
    } kboot_tag_video_t;

Fields:

 * `type`: Video mode type that has been set up (see `KBOOT_ITAG_VIDEO`). The
   remainder of the structure content is dependent on the video mode type.

Fields (`KBOOT_VIDEO_VGA`):

 * `cols`: Number of columns on the text display (in characters).
 * `lines`: Number of lines on the text display (in characters).
 * `x`: Current X position of the cursor.
 * `y`: Current Y position of the cursor.
 * `mem_phys`: Physical address of VGA memory (0xB8000 on PC).
 * `mem_virt`: Virtual address of a mapping of the VGA memory.
 * `mem_size`: Size of the virtual mapping (multiple of page size). The size of
   the mapping will be sufficient to access the entire screen (i.e. at least
   `cols * rows * 2`).

Fields (`KBOOT_VIDEO_LFB`);

 * `flags`: Flags indicating properties of the framebuffer. The lower 8 bits
   contain the colour The following flags
   are currently defined:
    - `KBOOT_LFB_RGB` (bit 0): The framebuffer is in direct RGB colour format.
    - `KBOOT_LFB_INDEXED` (bit 1): The framebuffer is in indexed colour format.
   The `KBOOT_LFB_RGB` and `KBOOT_LFB_INDEXED` flags are mutually exclusive.
 * `width`: Width of the video mode, in pixels.
 * `height`: Height of the video mode, in pixels.
 * `bpp`: Bits per pixel.
 * `pitch`: Number of bytes per line of the framebuffer.
 * `fb_phys`: Physical address of the framebuffer.
 * `fb_virt`: Virtual address of a mapping of the framebuffer.
 * `fb_size`: Size of the virtual mapping (multiple of the page size). The size
   of the mapping will be sufficient to access the entire screen (i.e. at least
   `pitch * height`).
 * `red_size`/`green_size`/`blue_size`: For `KBOOT_LFB_RGB` modes, these fields
   give the size, in bits, of the red, green and blue components of each pixel.
 * `red_pos`/`green_pos`/`blue_pos`: For `KBOOT_LFB_RGB` modes, these fields
   give the bit position within each pixel of the least significant bits of the
   red, green and blue components.
 * `palette_size`: For `KBOOT_LFB_INDEXED`, the number of colours in the given
   palette.
 * `palette`: For `KBOOT_LFB_INDEXED`, a variable length colour palette that
   has been set up by the boot loader.

### `KBOOT_TAG_BOOTDEV` (`8`)

This tag describes the device that the system was booted from.

    typedef uint8_t kboot_mac_addr_t[8];
    typedef uint8_t kboot_ipv4_addr_t[4];
    typedef uint8_t kboot_ipv6_addr_t[16];
    typedef union kboot_ip_addr {
    	kboot_ipv4_addr_t v4;
    	kboot_ipv6_addr_t v6;
    } kboot_ip_addr_t;
    
    typedef struct kboot_tag_bootdev {
    	kboot_tag_t header;
    
    	uint32_t method;
    
    	union {
    		struct {
    			uint32_t         flags;
    			uint8_t          uuid[64];
    			uint8_t          device;
    			uint8_t          partition;
    			uint8_t          sub_partition;
    		} disk;
    
    		struct {
    			uint32_t         flags;
    			kboot_ip_addr_t  server_ip;
    			uint16_t         server_port;
    			kboot_ip_addr_t  gateway_ip;
    			kboot_ip_addr_t  client_ip;
    			kboot_mac_addr_t client_mac;
    		} net;
    	};
    } kboot_tag_bootdev_t;

Fields:

 * `method`: Specifies the method used to boot. The following boot methods are
   currently defined:
    - `KBOOT_METHOD_NONE` (0): No boot device. This is the case when booted from
      a boot image.
    - `KBOOT_METHOD_DISK` (1): Booted from a disk device.
    - `KBOOT_METHOD_NET` (2): Booted from the network.
   The remainder of the structure is dependent on the method.

Fields (`KBOOT_METHOD_DISK`):

 * `flags`: Behaviour flags. No flags are currently defined.
 * `uuid`: If not zero-length, the UUID of the boot filesystem. It is
   recommended that this is used if present to identify the boot FS, as it is
   the most reliable method. See the section _Filesystem UUIDs_ for more
   information about this field.
 * `device`: Boot device number. This field is platform-specific. On the PC
   platform it contains the BIOS device number. It is currently undefined for
   other platforms.
 * `partition`: Partition number on the boot device. Partitions are numebered
   starting from 0. Logical partitions in DOS extended partitions start from 4.
   If not booted from a partition, will be set to `0xFF`.
 * `sub_partition`: Sub-partition number within the partition, e.g. for BSD
   disklabels. If not booted from a sub-partition, will be set to `0xFF`.

Fields (`KBOOT_METHOD_NET`):

 * `flags`: Behaviour flags. The following flags are currently defined:
    - `KBOOT_NET_IPV6`: The given IP addresses are IPv6 addresses, rather than
      IPv4 addresses.
 * `server_ip`: IP address of the server that was booted from.
 * `server_port`: UDP port number of the TFTP server.
 * `gateway_ip`: Gateway IP address.
 * `client_ip`: IP address that was used on this machine when communicating
   with the server.
 * `client_mac`: MAC address of the boot network interface.

### `KBOOT_TAG_LOG` (`9`)

This tag is part of an optional feature that enables the boot loader to display
a log from the kernel in the event of a crash. As long as the memory that
contains the log buffer is not cleared when the machine is reset, it can be
recovered by the boot loader. Whether this is supported is platform-dependent
(currently PC only). It is a rather rudimentary system, however it is useful to
assist in debugging, particularly on real hardware if no other mechanism is
available to obtain output from a kernel before a crash. A kernel indicates
that it wishes to use this feature by setting the `KBOOT_IMAGE_LOG` flag in the
`KBOOT_ITAG_IMAGE` tag. If the boot loader supports this feature, this tag type
will be included in the tag list.

    typedef struct kboot_tag_log {
    	kboot_tag_t   header;
    
    	kboot_vaddr_t log_virt;
    	kboot_paddr_t log_phys;
    	uint32_t      log_size;
    
    	kboot_paddr_t prev_phys;
    	uint32_t      prev_size;
    } kboot_tag_log_t;

Fields:

 * `log_virt`: Virtual address of the log buffer (aligned to page size).
 * `log_phys`: Physical address of the log buffer.
 * `log_size`: Total size of the log buffer (multiple of page size).
 * `prev_phys`: Physical address of the log buffer from the previous session.
 * `prev_size`: Total size of previous session log buffer. If 0, no previous
   log buffer was available.

The log buffer is a circular buffer. It includes a header at the start, any
remaining space contains the log itself. The header has the following format:

    typedef struct kboot_log {
    	uint32_t magic;
    
    	uint32_t start;
    	uint32_t length;
    
    	uint32_t info[3];
    	uint8_t  buffer[0];
    } kboot_log_t;

Fields:

 * `magic`: This field is used by the boot loader to identify a log buffer. Its
   exact value is not specified, it should not be modified by the kernel.
 * `start`: Offset in the buffer of the start of the log. A new log buffer will
   have this field initialized to 0. Must not exceed
   `(tag->log_size - sizeof(kboot_log_t))`.
 * `length`: Number of characters in the log buffer. A new log buffer will have
   this field initialized to 0. Must not exceed
   `(tag->log_size - sizeof(kboot_log_t))`.
 * `info`: These fields are free for use by the kernel. A new log buffer will
   have them initialized to 0, the previous session log buffer will contain
   the values written by the previous kernel.

The kernel should modify the `start` and `length` fields as it writes into the
buffer. An algorithm for writing to the buffer is shown below:

    log_size = tag->log_size - sizeof(kboot_log_t);
    log->buffer[(log->start + log->length) % log_size] = ch;
    if(log->length < log_size) {
    	log->length++;
    } else {
    	log->start = (log->start + 1) % log_size;
    }

### `KBOOT_TAG_SECTIONS` (`10`)

If the `KBOOT_IMAGE_SECTIONS` flag is specified in the `KBOOT_ITAG_IMAGE` image
tag, all additional loadable sections not normally loaded (ones with a zero
address in the headers, e.g. the symbol table and debug information) will be
loaded, and this tag will be passed containing the section header table. The
additional sections will be allocated in reclaimable physical memory, and mapped
into the virtual address space. The section headers will be modified to contain
the mapped address by the boot loader.

    typedef struct kboot_tag_sections {
    	kboot_tag_t header;
    
    	uint32_t    num;
    	uint32_t    entsize;
    	uint32_t    shstrndx;
    
    	uint32_t    padding;
    
    	char        sections[0];
    } kboot_tag_sections_t;

Fields:

 * `num`/`entsize`/`shstrndx`: These fields correspond to the fields with the
   same name in the ELF executable header.
 * `sections`: Array of section headers, each `entsize` bytes long.

Platform Specifics
------------------

### PC

If a video mode image tag is not included, VGA text mode will be used. If both
`KBOOT_VIDEO_LFB` and `KBOOT_VIDEO_VGA` are set, the boot loader will attempt
to set a framebuffer mode and fall back on VGA. It is recommended that a
kernel supports VGA text mode rather than exclusively using an LFB mode, as it
may not always be possible to set a LFB mode.

There are some information tags that are specific to the PC platform. These are
detailed below.

#### `KBOOT_TAG_E820` (`11`)

The PC BIOS provides more memory information than is included in the KBoot
physical memory map. Some of this information is required to support ACPI,
therefore KBoot will provide an unmodified copy of the BIOS E820 memory map
to the kernel. The tag list will contain an E820 tag for each address range
descriptor returned by INT 15h function E820h. Each tag's data will contain the
tag header and then the data returned by the BIOS. The format of each descriptor
as of ACPI 5.0 is as follows:

    typedef struct kboot_tag_e820 {
    	kboot_tag_t header;

    	uint64_t    start;
    	uint64_t    length;
    	uint32_t    type;
    	uint32_t    attr;
    } kboot_tag_e820_t;

The `start`, `length` and `type` fields are guaranteed to be present, however
any fields following them may not be present. The kernel should check the tag
size before accessing them.

Filesystem UUIDs
----------------

Some filesystems, such as ext2/3/4, have their own UUID. There are others that
do not, however for some it is possible to give a reasonably unique identifier
based on other information. This section describes what a boot loader should
give as a UUID for certain filesystems.

### ISO9660

The algorithm used to generate a UUID for ISO9660 filesystems originates from
the libblkid library on Linux. If the filesystem has a modification date set,
that is used, else the creation date is used, and formatted into the following:

    yyyy-mm-dd-hh-mm-ss-cc
